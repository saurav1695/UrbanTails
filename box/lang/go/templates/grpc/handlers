// Package handlers contains all http restful handlers
// Author : readyGo "JitenP@Outlook.Com"
// This code is generated by readyGo. You are free to make amendments as and where required
package handlers

import (
	"context"
	"{{.Project}}/interfaces"
	"{{.Project}}/models"
	{{- if .Model.MessagingModelSpec.MessageRespondType}}
	"{{.Project}}/messaging"
	{{- end}}
	pb "{{.Project}}/protos"
	"flag"
	"github.com/golang/glog"
	"github.com/fatih/structs"
	"github.com/mitchellh/mapstructure"
)

// {{.Model.Name}} type used as a container for db interface and receiver for handler functions
type {{.Model.Name}} struct {
	I{{.Model.Name}} interfaces.{{.Model.Name}}Interface
	pb.Unimplemented{{.Model.Name}}Server
	{{- if .Model.MessagingModelSpec.MessageRespondType}}
	Messaging *messaging.Messaging
	{{- end}}
}

func init() {
	flag.Parse()
	flag.Lookup("logtostderr").Value.Set("true")
}

// Create{{.Model.Name}} is to create object
func ({{.Model.Name | Initial}} *{{.Model.Name}}) Create{{.Model.Name}}(ctx context.Context, in *pb.{{.Model.Name}}Type) (*pb.{{.Model.Name}}Response, error) {
	{{.Model.Name | ToLower}} := &models.{{.Model.Name}}{}
	{{ $ModelName := .Model.Name }}
	sm := structs.Map(in)
	err:=mapstructure.Decode(sm, {{.Model.Name | ToLower}})
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	/*{{- range .Model.Fields }}
	{{$ModelName | ToLower}}.{{.Name}}=in.{{.Name}}
	{{- end}}*/
	out := &pb.{{.Model.Name}}Response{}
	if err := models.Validate{{.Model.Name}}({{.Model.Name | ToLower}}); err != nil {
		glog.Error(err)
		return nil, err
	}
	result,err:={{.Model.Name | Initial}}.I{{.Model.Name}}.Create{{.Model.Name}}({{.Model.Name | ToLower}});
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	{{- if eq .Model.MessagingModelSpec.MessageRespondType "publish"}}
			// If it is publisher
			b, _ := models.ToBytes({{.Model.Name | ToLower}})
			{{.Model.Name | Initial}}.Messaging.ChanMessage <- messaging.Message{Data: b, Subject: "{{.Model.MessagingModelSpec.Topic}}"}
	{{- end}}
	out.Code = 201
	out.Message = result
	return out, nil
}
// Update{{.Model.Name}}ByID is to update object in database
func ({{.Model.Name | Initial}} *{{.Model.Name}}) Update{{.Model.Name}}ByID(ctx context.Context, in *pb.{{.Model.Name}}UpdateRequest) (*pb.{{.Model.Name}}Response, error) {
	out := &pb.{{.Model.Name}}Response{}
	result,err:={{.Model.Name | Initial}}.I{{.Model.Name}}.Update{{.Model.Name}}ByID(in.ID,in.Data.AsMap());
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Code = 200
	out.Message = result
	return out, nil
}

// Delete{{.Model.Name}}ByID is to delete object from database
func ({{.Model.Name | Initial}} *{{.Model.Name}}) Delete{{.Model.Name}}ByID(ctx context.Context, in *pb.{{.Model.Name}}IDRequest) (*pb.{{.Model.Name}}Response, error) {
	out := &pb.{{.Model.Name}}Response{}
	result,err:={{.Model.Name | Initial}}.I{{.Model.Name}}.Delete{{.Model.Name}}ByID(in.ID);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Code = 200
	out.Message = result
	return out, nil
}

// Get{{.Model.Name}}ByID is to fetch object based on ID
func ({{.Model.Name | Initial}} *{{.Model.Name}}) Get{{.Model.Name}}ByID(ctx context.Context, in *pb.{{.Model.Name}}IDRequest) (*pb.{{.Model.Name}}Type, error) {
	{{.Model.Name | ToLower}} := &models.{{.Model.Name}}{}

	{{.Model.Name | ToLower}} ,err:={{.Model.Name | Initial}}.I{{.Model.Name}}.Get{{.Model.Name}}ByID(in.ID);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out := &pb.{{.Model.Name}}Type{}
	sm := structs.Map({{.Model.Name | ToLower}})
	err=mapstructure.Decode(sm, out)
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	/*{{ $ModelName := .Model.Name }}
	{{- range .Model.Fields }}
	out.{{.Name}}={{$ModelName | ToLower}}.{{.Name}}
	{{- end}}*/
	return out, nil
}


// GetAll{{.Model.Name}}sBy is to fetch all objects based on provided parameters
func ({{.Model.Name | Initial}} *{{.Model.Name}}) GetAll{{.Model.Name}}sBy(ctx context.Context, in *pb.{{.Model.Name}}GetAllByRequest) (*pb.{{.Model.Name}}sResponse, error) {
	{{.Model.Name | ToLower}}s := make([]models.{{.Model.Name}},0)
	{{.Model.Name | ToLower}}s ,err:={{.Model.Name | Initial}}.I{{.Model.Name}}.GetAll{{.Model.Name}}sBy(in.Key,in.Value,in.Skip,in.Limit);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out := &pb.{{.Model.Name}}sResponse{}
	for _,{{.Model.Name | ToLower}}:=range {{.Model.Name | ToLower}}s{
	single := &pb.{{.Model.Name}}Type{}
	{{ $ModelName := .Model.Name }}
	/*{{- range .Model.Fields }}
	single.{{.Name}}={{$ModelName | ToLower}}.{{.Name}}
	{{- end}}*/
	sm := structs.Map({{$ModelName | ToLower}})
	err = mapstructure.Decode(sm, single)
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.{{$ModelName}}s = append(out.{{$ModelName}}s,single)
	}
	return out, nil
}